[TOC]



# 什么是对象

在RT-Thread中，所有的数据结构都称之为对象

## 对象枚举定义

其中线程，信号量，互斥量、事件、邮箱、消息队列、内存堆、内存池、设备和定时器在rtdef.h中有明显的枚举定义，即为每个对象打上了一个数字标签

```c
enum rt_object_class_type2{
        RT_Object_Class_Thread=0,/*对象是线程*/
        RT_Object_Class_Semaphore,/*对象是信号量*/
        RT_Object_Class_Mutex,/*对象是互斥量*/
        RT_Object_Class_Event,/*对象是事件*/
        RT_Object_Class_MailBox,/*对象是邮箱*/
        RT_Object_Class_MessageQueue,/*对象是消息队列*/
        RT_Object_Class_MemHeap,/*对象是内存堆*/
        RT_Object_Class_MemPool,/*对象是内存池*/
        RT_Object_Class_Device,/*对象是设备*/
        RT_Object_Class_Timer,/*对象是定时器*/
        RT_Object_Class_Module,/*对象是模块*/
        RT_Object_Class_Unknown,/*对象未知*/
        RT_Object_Class_Static=0x80/*对象是静态对象*/
};
```

## 对象数据类型定义

在rtt中，为了方便管理这些对象，专门定义了一个对象类型数据结构

```c
struct rt_object
{
    char name[RT_NAME_MAX];/*内核对象的名字*/
    rt_uint8_t type;/*内核对象的类型*/
    rt_uint8_t flag;/*内核对象的状态*/
    rt_list_t list;/*内核对象的列表节点*/
};
typedef struct rt_object *rt_object_t;/*内核对象数据类型重定义*/
```

## 在线程控制块中添加对象成员

在RT-Thread中，每个对象都会有对应的一个结构体，这个结构体叫做该对象的控制块。如线程会有一个线程控制块，定时器会有一个定时器控制块，信号量会有信号量控制块等。

这些控制块的开头都会包含一个内核对象结构体，或者直接将对象结构体的成员放在对象控制块结构体的开头。其中线程控制块的开头放置的就是对象结构体的成员，其它内核对象的都是直接在其开头使用structrt_object直接定义一个内核对象变量。

```c
struct rt_thread
{
    /*rt对象*/
    char name[RT_NAME_MAX];/*对象的名字*/
    rt_uint8_t type;/*对象类型*/
    rt_uint8_t flags;/*对象的状态*/
    rt_list_t list;/*对象的列表节点*/
    rt_list_ttlist;/*线程链表节点*/
    void *sp;/*线程栈指针*/
    void *entry;/*线程入口地址*/
    void *parameter;/*线程形参*/
    void *stack_addr;/*线程起始地址*/
    rt_uint32_t stack_size;/*线程栈大小，单位为字节*/
};
```

# 什么是容器

在rtt中，每当用户创建一个对象，如线程，就会将这个对象放到一个叫做容器的地方，这样做的目的是为了方便管理，在RT-Thread的组件finsh的使用中，就需要使用到容器，通过扫描容器的内核对象来获取各个内核对象的状态，然后输出调试信息。

从代码上看，容器就是一个数组，是一个全局变量，数据类型为struct rt_object_information，在object.c中定义

## 容器的定义

容器是一个全部变量的数组，数据类型为struct rt_object_information，这是一个结构体类型，包含对象的三个信息，分别为对象类型、对象列表节点头和对象的大小，在rtdef.h中定义.

```c
static struct rt_object_information
rt_object_container[RT_Object_Info_Unknown]=
{
    /*初始化对象容器-线程*/
     {
        RT_Object_Class_Thread,
        _OBJ_CONTAINER_LIST_INIT(RT_Object_Info_Thread),
        sizeof(struct rt_thread)
	},
    ....
}
```

内核对象信息结构体定义

```c
struct rt_object_information
{
    enum rt_object_class_type type;//(1)/*对象类型*/
    rt_list_t object_list;//(2)/*对象列表节点头*/
    rt_size_t object_size;//(3)/*对象大小*/
};
```

对象的类型：取值只能是**rt_object_class_type**枚举类型

对象列表节点头：每当对象创建时，对象就会通过他们控制块里面的list节点将自己挂到对象容器中的对应列表，同一类型的对象是挂到对象容器中同一个对象列表的，容器数组的小标对应的就是对象的类型。

# 容器的接口实现（object.c）

## 获取指定类型的对象信息

从容器中获取指定类型的对象的信息由函数**rt_object_get_information()**实现

容器里面的成员是否初始化就不一定了，其中线程和定时器这两个对象默认会被初始化，剩下的其它对象由对应的宏决定。rt_object_get_information()会遍历整个容器对象，如果对象的类型等于我们指定的类型，那么就返回该容器成员的地址，地址的类型为struct rt_object_information。

## 对象初始化

每创建一个对象，都需要先将其初始化，主要分成两个部分的工作，首先将对象控制块里面与对象相关的成员初始化，然后将该对象插入到对象容器中

```c
该函数将初始化对象并将对象添加到对象容器中
*
*@paramobject要初始化的对象
*@paramtype对象的类型
*@paramname对象的名字，在整个系统中，对象的名字必须是唯一的
*/
void rt_object_init(struct rt_object *object,enum rt_object_class_type type,const char *name)
```

每个对象的控制块开头的成员都是对象信息相关的成员，比如一个线程控制块，它的开头前面4个成员都是与对象信息相关的，在调用rt_object_init()函数的时候，只需将线程控制块强制类型转化为struct rt_object作为第一个形参即可。

## 调用对象初始化函数

对象初始化函数在线程初始化函数里面被调用，如果创建了两个线程，在线程初始化之后，线程通过自身的list节点将自身挂到容器的对象列表中